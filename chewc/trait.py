# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_trait.ipynb.

# %% auto 0
__all__ = ['select_qtl_loci', 'TraitA']

# %% ../nbs/02_trait.ipynb 3
from .core import *
import torch
import attr
from typing import Tuple, Optional, List
from fastcore.test import *
import matplotlib.pyplot as plt
import torch.nn as nn
import pdb

def select_qtl_loci(num_qtl_per_chromosome: int, genome: Genome) -> torch.Tensor:
    """
    Randomly selects loci to be QTLs on each chromosome.

    Args:
    ----
    num_qtl_per_chromosome (int): Number of QTLs to select per chromosome.
    genome (Genome): Genome object containing the chromosome structure.
    device (str): Device to create the tensor on ('cpu' or 'cuda'). Defaults to 'cpu'.

    Returns:
    -------
    torch.Tensor: A boolean tensor indicating which loci are QTLs. 
                  Shape: (number_chromosomes, loci_per_chromosome)
    """
    
    assert num_qtl_per_chromosome <= genome.n_loci_per_chromosome, "too many qtls for this trait given your Genome object"
    assert num_qtl_per_chromosome > 0, "you need at least 1 QTL per chromosome"
    
    qtl_indices = []
    for i in range(genome.n_chromosomes):
        # Randomly sample indices for QTLs on the current chromosome
        chromosome_indices = torch.randperm(genome.n_loci_per_chromosome)[:num_qtl_per_chromosome]
        
        # Create a boolean tensor for the current chromosome, marking QTL positions as True
        chromosome_qtl_flags = torch.zeros(genome.n_loci_per_chromosome, dtype=torch.bool)
        chromosome_qtl_flags[chromosome_indices] = True
        
        qtl_indices.append(chromosome_qtl_flags)
    
    return torch.stack(qtl_indices)

class TraitA(nn.Module):
    def __init__(self, genome: Genome, effects: torch.Tensor, intercept: float):
        """
        Initialize the TraitA model.

        Args:
            genome (Genome): The genome object containing the genomic architecture.
            effects (torch.Tensor): The QTL effects tensor. Shape: (n_chromosomes, n_loci_per_chromosome).
            intercept (float): The intercept value for the trait model.
        """
        super().__init__()
        self.genome = genome
        self.effects = effects.to(genome.device)
        self.intercept = intercept

    def forward(self, dosages: torch.Tensor, h2: Optional[float] = None, varE: Optional[float] = None) -> torch.Tensor:
        """
        Forward pass to calculate the breeding values with optional environmental noise.

        Args:
            dosages (torch.Tensor): The dosage tensor. Shape: (population_size, n_chromosomes, n_loci_per_chromosome).
            h2 (float, optional): Heritability of the trait. If provided, environmental noise is added based on h2.
            varE (float, optional): Environmental variance. If provided, environmental noise is added based on varE.

        Returns:
            torch.Tensor: The calculated breeding values with optional environmental noise.
        """
        # Calculate breeding values
        breeding_values = torch.einsum('ijk,jk->i', dosages, self.effects) + self.intercept

        
        if varE is not None:
            # Add environmental noise based on environmental variance
            env_noise = torch.randn_like(breeding_values) * torch.sqrt(torch.tensor(varE))
            breeding_values += env_noise
        elif h2 is not None:
            # Calculate environmental variance from heritability
            varG = breeding_values.var(unbiased=False)
            varE = varG * (1 - h2) / h2
            env_noise = torch.randn_like(breeding_values) * torch.sqrt(varE)
            breeding_values += env_noise

        return breeding_values
