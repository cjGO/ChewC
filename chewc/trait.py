# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_trait.ipynb.

# %% auto 0
__all__ = ['select_qtl_loci', 'calculate_genetic_variance', 'TraitA']

# %% ../nbs/02_trait.ipynb 3
from .core import *
import torch
import attr
from typing import Tuple, Optional, List
from fastcore.test import *
import matplotlib.pyplot as plt

def select_qtl_loci(num_qtl_per_chromosome: int, genome:Genome) -> torch.Tensor:
    """
    Randomly selects loci to be QTLs on each chromosome.

    Args:
    ----
    num_qtl_per_chromosome (int): Number of QTLs to select per chromosome.
    genome (Genome): Genome object containing the chromosome structure.

    Returns:
    -------
    torch.Tensor: A boolean tensor indicating which loci are QTLs. 
                  Shape: (number_chromosomes, loci_per_chromosome)
    """
    
    assert num_qtl_per_chromosome <= genome.loci_per_chromosome, "too many qtls for this trait given your Genome object"
    assert num_qtl_per_chromosome > 0, "you need at least 1 QTL per chromosome"
    

    qtl_indices = []
    for i in range(genome.number_chromosomes):
        # Randomly sample indices for QTLs on the current chromosome
        chromosome_indices = torch.randperm(genome.loci_per_chromosome)[:num_qtl_per_chromosome]
        
        # Create a boolean tensor for the current chromosome, marking QTL positions as True
        chromosome_qtl_flags = torch.zeros(genome.loci_per_chromosome, dtype=torch.bool)
        chromosome_qtl_flags[chromosome_indices] = True
        
        qtl_indices.append(chromosome_qtl_flags)
    
    return torch.stack(qtl_indices)

# %% ../nbs/02_trait.ipynb 4
def calculate_genetic_variance(founder_pop: torch.Tensor, marker_effects: torch.Tensor, genome: Genome) -> float:
    """
    Calculates the additive genetic variance in the founder population.

    Args:
        founder_pop (torch.Tensor): Tensor of founder haplotypes. 
                                    Shape: (n_founders, ploidy, number_chromosomes, loci_per_chromosome)
        marker_effects (torch.Tensor): Tensor of marker effects. 
                                       Shape: (number_chromosomes, loci_per_chromosome)
        genome (Genome): The genome object.

    Returns:
        torch.Tensor: The additive genetic variance.
    """
    # Convert to float for mean operation to work
    founder_pop = founder_pop.float()
    # Calculate allele frequencies in the founder population
    allele_frequencies = founder_pop.mean(dim=(0, 1))  # Average across founders and ploidy

    # Calculate the genetic value contributions of each locus
    locus_contributions = 2 * allele_frequencies * (1 - allele_frequencies) * marker_effects**2

    # Sum the contributions across all loci to get the total genetic variance
    genetic_variance = locus_contributions.sum().item()

    return genetic_variance

# %% ../nbs/02_trait.ipynb 5
@attr.s(auto_attribs=True)
class TraitA:
    """
    Represents a trait with only additive genetic effects.

    Attributes:
    ----------
    qtl_map (torch.Tensor): A boolean tensor indicating which loci are QTLs. 
                           Shape: (number_chromosomes, loci_per_chromosome)
    genome (Genome): The genome object.
    founder_pop (torch.Tensor): Tensor of founder haplotypes. 
                                Shape: (n_founders, ploidy, number_chromosomes, loci_per_chromosome)
    target_mean (float): The desired genetic mean for the trait.
    target_variance (float): The desired genetic variance for the trait.
    additive_effects (torch.Tensor, optional): A tensor of additive effects for each QTL 
                                           (if pre-generated). Defaults to None.
    intercept (float): The intercept value, calculated during initialization.
    
    Methods:
    -------

    """

    qtl_map: torch.Tensor 
    sim_param: SimParam
    target_mean: float
    target_variance: float
    distribution: str ='normal'
        
    def calculate_scaled_additive_dosages(self, genotypes: torch.Tensor) -> torch.Tensor:
        """
        Calculates the scaled additive genotype dosages.

        Args:
            genotypes (torch.Tensor): A tensor representing the genotypes of individuals.
                                     Shape: (n_individuals, ploidy, number_chromosomes, loci_per_chromosome).

        Returns:
            torch.Tensor: A tensor of scaled additive dosages. 
                         Shape: (n_individuals, ploidy, number_chromosomes, loci_per_chromosome).
        """
        return (genotypes - self.sim_param.genome.ploidy / 2) * (2 / self.sim_param.genome.ploidy)

    def sample_initial_effects(self):
        """
        Sample initial values for the genetic effects based on the specified distribution.
        """
        if self.distribution == 'normal':
            # Sample from a standard normal distribution
            effects = torch.randn(self.sim_param.genome.genetic_map.shape)
        elif self.distribution == 'gamma':
            # Sample from a gamma distribution with specified shape and scale=1
            effects = torch.distributions.Gamma(self.shape, 1).sample((self.sim_param.genome.genetic_map.shape,))
            # Randomly assign a positive or negative sign
            signs = torch.tensor(np.random.choice([-1, 1], self.sim_param.genome.genetic_map.shape))
            effects *= signs
        else:
            raise ValueError("Unsupported distribution type. Choose 'normal' or 'gamma'.")
        self.initial_effects = effects
        
    def scale_genetic_effects(self):
        """
        Scale the marker effects to achieve a specified genetic variance in the founder population.

        Parameters:
        founder_pop (torch.Tensor): Tensor representing the founder population. Shape: [num_individuals, num_chromosomes, dim1, dim2]
        marker_effects (torch.Tensor): Tensor of marker effects. Shape: [dim1, dim2]
        target_variance (float): The target genetic variance to achieve.

        Returns:
        torch.Tensor: Scaled marker effects.
        """
        # Step 1: Calculate the genetic value for each individual using the initally sampled marker effects
        genetic_values = (self.sim_param.founder_pop * self.initial_effects.unsqueeze(0).unsqueeze(0)).sum(dim=[1,2, 3])
        # Step 2: Calculate the initial genetic variance
        initial_variance = genetic_values.var(dim=0)
        # Step 3: Calculate scaling constant and scale the effects
        scaling_factor = torch.sqrt(self.target_variance / initial_variance)
        scaled_effects = self.initial_effects * scaling_factor
        self.scaled_effects = scaled_effects

    def calculate_genetic_values(self, pop):
        """
        Calculates the genetic value for each individual in a pop [ind,ploidy,chr,loci]
        """
        # pop.shape = [50,2,10,10]
        # self.scaled_effects.shape = [10,10]
        # output [50]
        return torch.einsum('ijkl,kl->i', self.calculate_scaled_additive_dosages(pop.float()), self.scaled_effects)

    def calculate_intercept(self):
        """
        Calculate the intercept to achieve the desired mean genetic value of the population.
        """
        current_mean = self.calculate_genetic_values(self.sim_param.founder_pop).mean()
        self.intercept = self.target_mean - current_mean
        

    def phenotype(self, pop, h2=None, varE=None):
        """
        Generate phenotypes for the individuals in the population.

        Args:
        pop (Pop): The population object.
        h2 (float, optional): Target narrow-sense heritability. Defaults to None.
        varE (float, optional): Target environmental variance. Defaults to None.

        Returns:
        torch.Tensor: A tensor of phenotype values for each individual.
                       Shape: (n_individuals,)

        Raises:
        ValueError: If both h2 and varE are provided or neither are provided.
        """

        if h2 is not None and varE is not None:
            raise ValueError("Provide either h2 or varE, not both.")
        if h2 is None and varE is None:
            raise ValueError("Provide either h2 or varE.")

        genetic_values = self.calculate_genetic_values(pop) + self.intercept

        if h2 is not None:
            # Calculate varE based on target heritability
            varG = genetic_values.var()
            varE = (varG / h2) - varG  
        
        # Generate environmental error
        error = torch.randn(len(pop)) * torch.sqrt(varE)

        # Calculate phenotypes
        phenotypes = genetic_values + error
        
        return phenotypes
    
