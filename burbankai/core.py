# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['Genome', 'Individual']

# %% ../nbs/01_core.ipynb 3
import attr
import torch
import numpy as np
from typing import List, Tuple, Union, Callable, Optional

# %% ../nbs/01_core.ipynb 5
@attr.s(auto_attribs=True)
class Genome:
    """
    Used for defining the genomic architecture for the simulation. 
    It will be used as an argument for breeding program operations.
    
    Args:
        ploidy (int): Ploidy level (assuming autopolyploid).
        number_chromosomes (int): Total number of chromosomes in the karyotype/genome.
        loci_per_chromosome (int): The number of loci which are genotyped on each chromosome (e.g., a SNP chip).
        genetic_map (torch.Tensor): A 2D tensor representing the genetic map. 
                                     Shape: (number_chromosomes, loci_per_chromosome). 
                                     Each row represents a chromosome, and each element in a row is the genetic 
                                     location (in cM) of a locus.
    """
    ploidy: int
    number_chromosomes: int
    loci_per_chromosome: int
    genetic_map: torch.Tensor

    def __attrs_post_init__(self):
        """
        Validate the input parameters after initialization.
        """
        # Check if the genetic map dimensions are compatible
        if not self.genetic_map.shape == (self.number_chromosomes, self.loci_per_chromosome):
            raise ValueError(f"Genetic map shape {self.genetic_map.shape} is incompatible with the number of chromosomes and loci per chromosome.")

        # Check if the genetic map is valid (starts at 0 and is increasing)
        for chrom_map in self.genetic_map:
            if not (chrom_map[0] == 0 and all(x < y for x, y in zip(chrom_map, chrom_map[1:]))):
                raise ValueError("The genetic map must start at 0 and be strictly increasing for each chromosome.")


# %% ../nbs/01_core.ipynb 6
@attr.s(auto_attribs=True)
class Individual:
    """
    Represents an individual in the breeding simulation.

    Args:
        genome (Genome): Reference to the shared Genome object.
        haplotypes (torch.Tensor): Tensor representing the individual's haplotypes. 
                                    Shape: (number_chromosomes, ploidy, number_loci).
        id (Optional[str]): Unique identifier. Defaults to None.
        mother_id (Optional[str]): Mother's identifier. Defaults to None.
        father_id (Optional[str]): Father's identifier. Defaults to None.
        genetic_value (Optional[torch.Tensor]): Genetic value for traits. Shape: (number_traits,). Defaults to None.
        phenotype (Optional[torch.Tensor]): Phenotype for traits. Shape: (number_traits,). Defaults to None.
    """
    genome: Genome
    haplotypes: torch.Tensor # haplotypes.shape == genome.genetic_map.shape
    id: Optional[str] = None
    mother_id: Optional[str] = None
    father_id: Optional[str] = None
    genetic_value: Optional[torch.Tensor] = None
    phenotype: Optional[torch.Tensor] = None

    def __attrs_post_init__(self):
        """
        Validate the input parameters after initialization.
        """
        # make sure the haplotype and given genetic map are compatible. 
        if not self.haplotypes.shape == self.genome.gentic_map.shape:
            raise ValueError(f"Haplotype shape {self.haplotypes.shape[1:]} is incompatible with the genome {self.genome.genetic_map.shape}.")
        
